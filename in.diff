diff --git a/config/index.md b/config/index.md
--- config/index.md
+++ config/index.md
@@ -74,9 +74,9 @@
     }
   } else {
     // command === 'build'
     return {
-      // configuration spÃ©cifique au mode build
+      // configuration spÃ©cifique au mode compilation
     }
   }
 })
 ```
@@ -132,9 +132,9 @@
 ### define

 - **Typeâ€¯:** `Record<string, string>`

-  DÃ©finit des constantes globales. Les valeurs saisies seront dÃ©finies comme des variables globales en dÃ©veloppement et remplacÃ©es statiquement pendant le build.
+  DÃ©finit des constantes globales. Les valeurs saisies seront dÃ©finies comme des variables globales en dÃ©veloppement et remplacÃ©es statiquement pendant la compilation.

   - Depuis la version `2.0.0-beta.70`, les chaÃ®nes de caractÃ¨res sont utilisÃ©es comme des expressions brutes, donc si vous dÃ©finissez une chaÃ®ne de caractÃ¨res constante, elle doit Ãªtre explicitement mise entre crochets (avec `JSON.stringify` par exemple).

   - Les remplacements sont faits seulement lorsque la correspondance est entourÃ©e par des dÃ©limiteurs de mots (`\b`).
@@ -165,9 +165,9 @@

 - **Typeâ€¯:** `string | false`
 - **Valeur par dÃ©fautâ€¯:** `"public"`

-  RÃ©pertoire dâ€™oÃ¹ servir les ressources statiques. Les fichiers de ce rÃ©pertoires sont servis Ã  `/` pendant le dÃ©veloppement et copiÃ©s Ã  la racine de `outDir` pendant le build, et ils sont toujours servis ou copiÃ©s tels quels sans aucune transformation. La valeur peut Ãªtre soit un chemin absolu sur tout le systÃ¨me de fichiers, soit un chemin relatif Ã  la racine du projet. La valeur par dÃ©faut est `.vite` quand aucun package.json nâ€™est dÃ©tectÃ©.
+  RÃ©pertoire dâ€™oÃ¹ servir les ressources statiques. Les fichiers de ce rÃ©pertoires sont servis Ã  `/` pendant le dÃ©veloppement et copiÃ©s Ã  la racine de `outDir` pendant la compilation, et ils sont toujours servis ou copiÃ©s tels quels sans aucune transformation. La valeur peut Ãªtre soit un chemin absolu sur tout le systÃ¨me de fichiers, soit un chemin relatif Ã  la racine du projet. La valeur par dÃ©faut est `.vite` quand aucun package.json nâ€™est dÃ©tectÃ©.

   DÃ©finir `publicDir` Ã  `false` dÃ©sactive cette fonctionnalitÃ©.

   Voir [Le rÃ©pertoire `public`](/guide/assets#le-repertoire-public) pour plus de dÃ©tails.
@@ -195,9 +195,9 @@

   Si vous avez des duplications dâ€™une mÃªme dÃ©pendance dans votre app (probablement Ã  cause du hoisting ou de packages liÃ©s dans les monorepos), utilisez cette option pour forcer Vite Ã  toujours rÃ©soudre les dÃ©pendances Ã  la mÃªme copie (celle Ã  la racine du projet).

   :::warning SSR + ESM
-  Pour les builds SSR, la dÃ©duplication ne fonctionne pas pour les builds ESM configurÃ©s via `build.rollupOptions.output`. Vous pouvez contourner cette limitation en utilisant des builds CJS en attendant quâ€™ESM propose un meilleur support des plugins pour le chargement de modules.
+  Pour les compilations SSR, la dÃ©duplication ne fonctionne pas pour la compilation en ESM configurÃ©e via `build.rollupOptions.output`. Vous pouvez contourner cette limitation en utilisant une compilation CJS en attendant quâ€™ESM propose un meilleur support des plugins pour le chargement de modules.
   :::

 ### resolve.conditions

@@ -656,9 +656,9 @@
     }
   })
   ```

-## Options du build
+## Options de compilation

 ### build.target

 - **Typeâ€¯:** `string | string[]`
@@ -673,18 +673,18 @@
   - Sinon, aucune transpilation ne sera effectuÃ©e.

   La transformation est rÃ©alisÃ©e Ã  lâ€™aide dâ€™esbuild et la valeur doit Ãªtre une [option target dâ€™esbuild](https://esbuild.github.io/api/#target) valide. Les valeurs spÃ©cifiÃ©es peuvent Ãªtre soit une version dâ€™ECMAScript (par exemple `es2015`), une version de navigateur (par exemple `chrome58`), ou un array de plusieurs cibles comme celles-ci.

-  Notez que le build Ã©chouera sâ€™il y a des fonctionnalitÃ©s qui ne peuvent pas Ãªtre transpilÃ©es par esbuild. Voir la [documentation dâ€™esbuild](https://esbuild.github.io/content-types/#javascript) pour de plus amples dÃ©tails.
+  Notez que la compilation Ã©chouera sâ€™il y a des fonctionnalitÃ©s qui ne peuvent pas Ãªtre transpilÃ©es par esbuild. Voir la [documentation dâ€™esbuild](https://esbuild.github.io/content-types/#javascript) pour de plus amples dÃ©tails.

 ### build.polyfillModulePreload

 - **Typeâ€¯:** `boolean`
 - **Valeur par dÃ©fautâ€¯:** `true`

   DÃ©finit si le [polyfill de module preload](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) doit Ãªtre injectÃ© automatiquement.

-  Si cette option est dÃ©finie Ã  `true`, le polyfill est automatiquement injectÃ© au module proxy de chaque entrÃ©e `index.html`. Si le build est configurÃ© pour utiliser une entrÃ©e spÃ©cifique non-HTML Ã  lâ€™aide de `build.rollupOptions.input`, alors il faut importer manuellement le polyfill dans ladite entrÃ©eâ€¯:
+  Si cette option est dÃ©finie Ã  `true`, le polyfill est automatiquement injectÃ© au module proxy de chaque entrÃ©e `index.html`. Si la compilation est configurÃ© pour utiliser une entrÃ©e spÃ©cifique non-HTML Ã  lâ€™aide de `build.rollupOptions.input`, alors il faut importer manuellement le polyfill dans ladite entrÃ©eâ€¯:

   ```js
   import 'vite/modulepreload-polyfill'
   ```
@@ -777,25 +777,25 @@
 - **Typeâ€¯:** `boolean`
 - **Valeur par dÃ©fautâ€¯:** `false`
 - **Voir aussiâ€¯:** [IntÃ©gration du back-end](/guide/backend-integration)

-  Quand cette option est Ã  `true`, le build gÃ©nÃ©rera Ã©galement un fichier `manifest.json` contenant un mapping entre les noms de fichiers de ressources non-hashÃ©s et leurs versions hashÃ©es, qui peut ensuite Ãªtre utilisÃ© par un framework serveur afin de rendre les bons liens de ressources.
+  Quand cette option est Ã  `true`, la compilation gÃ©nÃ©rera Ã©galement un fichier `manifest.json` contenant un mapping entre les noms de fichiers de ressources non-hashÃ©s et leurs versions hashÃ©es, qui peut ensuite Ãªtre utilisÃ© par un framework serveur afin de rendre les bons liens de ressources.

 ### build.ssrManifest

 - **Typeâ€¯:** `boolean`
 - **Valeur par dÃ©fautâ€¯:** `false`
 - **Voir aussiâ€¯:** [Rendu cÃ´tÃ© serveur (SSR)](/guide/ssr)

-  Quand cette option est Ã  `true`, le build gÃ©nÃ©rera Ã©galement un manifeste de rendu cÃ´tÃ© serveur permettant de dÃ©terminer les liens de style ainsi que les directives de prÃ©-chargement (_preload directives_) des ressources en production.
+  Quand cette option est Ã  `true`, la compilation gÃ©nÃ©rera Ã©galement un manifeste de rendu cÃ´tÃ© serveur permettant de dÃ©terminer les liens de style ainsi que les directives de prÃ©-chargement (_preload directives_) des ressources en production.

 ### build.ssr

 - **Typeâ€¯:** `boolean | string`
 - **Valeur par dÃ©fautâ€¯:** `undefined`
 - **Voir aussiâ€¯:** [Rendu cÃ´tÃ© serveur (SSR)](/guide/ssr)

-  DÃ©finit si le build doit Ãªtre orientÃ© vers un rendu cÃ´tÃ© serveur. La valeur peut Ãªtre une chaÃ®ne spÃ©cifiant directement lâ€™entrÃ©e de rendu cÃ´tÃ© serveur, ou `true`, ce qui requiert de spÃ©cifier lâ€™entrÃ©e de rendu cÃ´tÃ© serveur Ã  lâ€™aide de `rollupOptions.input`.
+  DÃ©finit si la compilation doit Ãªtre orientÃ© vers un rendu cÃ´tÃ© serveur. La valeur peut Ãªtre une chaÃ®ne spÃ©cifiant directement lâ€™entrÃ©e de rendu cÃ´tÃ© serveur, ou `true`, ce qui requiert de spÃ©cifier lâ€™entrÃ©e de rendu cÃ´tÃ© serveur Ã  lâ€™aide de `rollupOptions.input`.

 ### build.minify

 - **Typeâ€¯:** `boolean | 'terser' | 'esbuild'`
@@ -822,9 +822,9 @@

 - **Typeâ€¯:** `boolean`
 - **Valeur par dÃ©fautâ€¯:** `true` si `outDir` est dans `root`

-  Par dÃ©faut, Vite videra le `outDir` lors du build sâ€™il se trouve dans la racine projet. Il Ã©mettra un avertissement si `outDir` est en dehors de la racine projet pour empÃªcher de retirer accidentellement des fichiers importants. Vous pouvez dÃ©finir explicitement cette option pour retirer lâ€™avertissement. Elle est Ã©galement disponible avec lâ€™interface en ligne de commande en tant que `--emptyOutDir`.
+  Par dÃ©faut, Vite videra le `outDir` lors de la compilation sâ€™il se trouve dans la racine projet. Il Ã©mettra un avertissement si `outDir` est en dehors de la racine projet pour empÃªcher de retirer accidentellement des fichiers importants. Vous pouvez dÃ©finir explicitement cette option pour retirer lâ€™avertissement. Elle est Ã©galement disponible avec lâ€™interface en ligne de commande en tant que `--emptyOutDir`.

 ### build.reportCompressedSize

 - **Typeâ€¯:** `boolean`
@@ -843,9 +843,9 @@

 - **Typeâ€¯:** [`WatcherOptions`](https://rollupjs.org/guide/en/#watch-options)`| null`
 - **Valeur par dÃ©fautâ€¯:** `null`

-  DÃ©finissez cette option Ã  `{}` pour activer le watcher de Rollup. Cette option est surtout utile dans des contextes oÃ¹ les plugins sont build-only ou pour les process dâ€™intÃ©gration.
+  DÃ©finissez cette option Ã  `{}` pour activer l'observateur de fichier de Rollup. Cette option est surtout utile dans des contextes oÃ¹ les plugins sont build-only ou pour les process dâ€™intÃ©gration.

 ## Options de lâ€™aperÃ§u (_preview_)

 ### preview.host
@@ -990,9 +990,9 @@

 - **Typeâ€¯:** `'node' | 'webworker'`
 - **Valeur par dÃ©fautâ€¯:** `node`

-  Environnement ciblÃ© pour le build cÃ´tÃ© serveur.
+  Environnement ciblÃ© pour la compilation cÃ´tÃ© serveur.

 ## Options du worker

 ### worker.format
diff --git a/index.md b/index.md
--- index.md
+++ index.md
@@ -8,17 +8,17 @@
 altActionLink: /guide/why

 features:
   - title: ğŸ’¡ DÃ©marrage instantanÃ© du serveur
-    details: Les fichiers sont servis instantanÃ©ment sous la forme de modules ESMâ€¯! Il nâ€™y a pas besoin de builder.
+    details: Les fichiers sont servis instantanÃ©ment sous la forme de modules ESMâ€¯! Il nâ€™y a pas besoin de compiler.
   - title: âš¡ï¸ RafraÃ®chissement des modules ultra rapide
     details: Pendant le dÃ©veloppement, les modules sont remplacÃ©s rapidement peu importe la taille de lâ€™app.
   - title: ğŸ› ï¸ Riche en fonctionnalitÃ©s
     details: Support inclus pour Typescript, JSX, CSS, et bien dâ€™autres.
-  - title: ğŸ“¦ Build optimisÃ©
-    details: Le build se fait grÃ¢ce Ã  Rollup, prÃ©-configurÃ© et avec le support du multi-page et du mode librairie.
+  - title: ğŸ“¦ Compilation optimisÃ©e
+    details: La compilation se fait grÃ¢ce Ã  Rollup, prÃ©-configurÃ© et avec le support du multi-page et du mode librairie.
   - title: ğŸ”© Interface universelle de plugins
-    details: Interface de plugins basÃ©e sur Rollup et partagÃ©e entre dÃ©veloppement et build.
+    details: Interface de plugins basÃ©e sur Rollup et partagÃ©e entre dÃ©veloppement et compilation.
   - title: ğŸ”‘ APIs typÃ©es
     details: APIs programmatiques flexibles avec dÃ©finition TypeScript de tous les types.
 footer: Licence MIT | Copyright Â© 2019-aujourdâ€™hui Evan You & les contributeurs Ã  Vite
 ---
diff --git a/README.md b/README.md
--- README.md
+++ README.md
@@ -6,9 +6,9 @@
 <br/>
 <p align="center">
   <a href="https://npmjs.com/package/vite"><img src="https://img.shields.io/npm/v/vite.svg" alt="npm package"></a>
   <a href="https://nodejs.org/en/about/releases/"><img src="https://img.shields.io/node/v/vite.svg" alt="node compatibility"></a>
-  <a href="https://github.com/vitejs/vite/actions/workflows/ci.yml"><img src="https://github.com/vitejs/vite/actions/workflows/ci.yml/badge.svg?branch=main" alt="build status"></a>
+  <a href="https://github.com/vitejs/vite/actions/workflows/ci.yml"><img src="https://github.com/vitejs/vite/actions/workflows/ci.yml/badge.svg?branch=main" alt="statut de compilation"></a>
   <a href="https://chat.vitejs.dev"><img src="https://img.shields.io/badge/chat-discord-blue?style=flat&logo=discord" alt="discord chat"></a>
 </p>
 <br/>

@@ -26,9 +26,9 @@
 Vite (prononcÃ© comme en franÃ§ais) est un outil de compilation frontend dâ€™un nouveau genre qui amÃ©liore grandement lâ€™expÃ©rience de dÃ©veloppement. Il se compose de deux partiesâ€¯:

 - Un serveur de dÃ©veloppement qui sert les fichiers sous la forme de [modules ECMAScript](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules), qui propose de [nombreuses fonctionnalitÃ©s](https://vitejs.dev/guide/features.html) et qui permet un [rafraÃ®chissement des modules (HMR)](https://vitejs.dev/guide/features.html#hot-module-replacement) trÃ¨s rapide.

-- Une [commande de build](https://vitejs.dev/guide/build.html) qui bundle votre code Ã  lâ€™aide de [Rollup](https://rollupjs.org), prÃ©-configurÃ© pour optimiser grandement la taille des ressources statiques en production.
+- Une [commande de compilation](https://vitejs.dev/guide/build.html) qui bundle votre code Ã  lâ€™aide de [Rollup](https://rollupjs.org), prÃ©-configurÃ© pour optimiser grandement la taille des ressources statiques en production.

 En plus, Vite peut Ãªtre Ã©tendu grÃ¢ce Ã  son [API pour plugin](https://vitejs.dev/guide/api-plugin.html) ainsi que lâ€™[API JavaScript](https://vitejs.dev/guide/api-javascript.html) typÃ©e.

 ## Contribution
diff --git a/.vitepress/config.js b/.vitepress/config.js
--- .vitepress/config.js
+++ .vitepress/config.js
@@ -110,9 +110,9 @@
               text: 'Gestion des ressources statiques',
               link: '/guide/assets'
             },
             {
-              text: 'Build de production',
+              text: 'Compilation de production',
               link: '/guide/build'
             },
             {
               text: 'DÃ©ployer un site statique',
diff --git a/blog/announcing-vite2.md b/blog/announcing-vite2.md
--- blog/announcing-vite2.md
+++ blog/announcing-vite2.md
@@ -9,9 +9,9 @@
 </p>

 Nous sommes trÃ¨s heureux dâ€™annoncer aujourdâ€™hui la sortie officielle de Vite 2.0â€¯!

-Vite (du mot franÃ§ais) est un outil de build web front-end dâ€™un nouveau genre. Vous pouvez le voir comme un combo entre un serveur de dÃ©veloppement prÃ©-configurÃ© et un bundler, mais en plus lÃ©ger et plus rapide. Il sâ€™appuie sur le support des [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules) de votre navigateur et sur des outils Ã©crits dans des langages compilÃ©s comme [esbuild](https://esbuild.github.io/) pour fournir une expÃ©rience de dÃ©veloppement vive et moderne.
+Vite (du mot franÃ§ais) est un outil de compilation web front-end dâ€™un nouveau genre. Vous pouvez le voir comme un combo entre un serveur de dÃ©veloppement prÃ©-configurÃ© et un bundler, mais en plus lÃ©ger et plus rapide. Il sâ€™appuie sur le support des [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules) de votre navigateur et sur des outils Ã©crits dans des langages compilÃ©s comme [esbuild](https://esbuild.github.io/) pour fournir une expÃ©rience de dÃ©veloppement vive et moderne.

 Pour vous faire une idÃ©e dâ€™Ã  quel point Vite est rapide, regardez cette [comparaison vidÃ©o](https://twitter.com/amasad/status/1355379680275128321) entre dÃ©marrer une application React sur Repl.it en utilisant Vite et en utilisant `create-react-app` (CRA).

 Si vous nâ€™aviez jamais entendu parler de Vite jusquâ€™ici et que vous voudriez en savoir plus, nous avons une page expliquant les [raisons qui motivent le projet](https://vitejs.dev/guide/why.html). Si vous vous demandez en quoi Vite diffÃ¨re des outils similaires, nous avons aussi une page de [comparaisons](https://vitejs.dev/guide/comparisons.html).
@@ -27,9 +27,9 @@
 Vite 2.0 capitalise sur ce que nous avons appris en cours de route et il a Ã©tÃ© complÃ¨tement redesignÃ© pour disposer dâ€™une architecture interne plus robuste. Il est dÃ©sormais entiÃ¨rement indÃ©pendant du framework utilisÃ©, et tout ce qui est spÃ©cifique aux frameworks est dÃ©lÃ©guÃ© aux plugins. Il y a maintenant des [templates officiels pour Vue, React, Preact, Lit Element](https://github.com/vitejs/vite/tree/main/packages/create-vite) et la communautÃ© travaille en ce moment mÃªme Ã  lâ€™intÃ©gration de Svelte.

 ### Nouveau format de plugins et API

-Le nouveau systÃ¨me de plugins, inspirÃ© par [WMR](https://github.com/preactjs/wmr), Ã©tend lâ€™interface pour plugins de Rollup et est [compatible avec beaucoup de plugins Rollup](https://vite-rollup-plugins.patak.dev/) sans quâ€™il nâ€™y ait besoin dâ€™adaptations. Les plugins peuvent utiliser les hooks de Rollup, ainsi que des hooks et des propriÃ©tÃ©s supplÃ©mentaires spÃ©cifiques Ã  Vite (par exemple pour diffÃ©rencier entre dÃ©veloppement et build ou pour gÃ©rer diffÃ©remment le rafraÃ®chissement des modules Ã  la volÃ©e).
+Le nouveau systÃ¨me de plugins, inspirÃ© par [WMR](https://github.com/preactjs/wmr), Ã©tend lâ€™interface pour plugins de Rollup et est [compatible avec beaucoup de plugins Rollup](https://vite-rollup-plugins.patak.dev/) sans quâ€™il nâ€™y ait besoin dâ€™adaptations. Les plugins peuvent utiliser les hooks de Rollup, ainsi que des hooks et des propriÃ©tÃ©s supplÃ©mentaires spÃ©cifiques Ã  Vite (par exemple pour diffÃ©rencier entre dÃ©veloppement et compilation ou pour gÃ©rer diffÃ©remment le rafraÃ®chissement des modules Ã  la volÃ©e).

 Lâ€™[API programmatique](https://vitejs.dev/guide/api-javascript.html) a Ã©galement Ã©tÃ© beaucoup amÃ©liorÃ©e pour faciliter lâ€™apparition dâ€™outils ou de frameworks de plus haut niveau par-dessus Vite.

 ### PrÃ©-bundling des dÃ©pendances Ã  lâ€™aide dâ€™esbuild
@@ -45,9 +45,9 @@
 - **Fractionnement (_code splitting_) du CSS**â€¯: un morceau (_chunk_) en JS Ã©met Ã©galement le CSS correspondant, qui sera automatiquement chargÃ© en parallÃ¨le de ce dernier.

 ### Support du rendu cÃ´tÃ© serveur (_SSR_)

-Vite 2.0 est livrÃ© avec le [support expÃ©rimental du rendu cÃ´tÃ© serveur](https://vitejs.dev/guide/ssr.html). Vite fournit des APIs afin de charger et de mettre Ã  jour efficacement le code source ESM en Node.js pendant le dÃ©veloppement (presque comme du rafraÃ®chissement de modules Ã  la volÃ©e cÃ´tÃ© serveur), et externalise automatiquement les dÃ©pendances compatibles avec CommonJS pour accÃ©lÃ©rer la vitesse du build. Le serveur de production peut Ãªtre complÃ¨tement dÃ©couplÃ© de Vite, et le mÃªme setup peut Ãªtre facilement adaptÃ© pour permettre le prÃ©-rendu / la gÃ©nÃ©ration statique (_SSG_).
+Vite 2.0 est livrÃ© avec le [support expÃ©rimental du rendu cÃ´tÃ© serveur](https://vitejs.dev/guide/ssr.html). Vite fournit des APIs afin de charger et de mettre Ã  jour efficacement le code source ESM en Node.js pendant le dÃ©veloppement (presque comme du rafraÃ®chissement de modules Ã  la volÃ©e cÃ´tÃ© serveur), et externalise automatiquement les dÃ©pendances compatibles avec CommonJS pour accÃ©lÃ©rer la vitesse de la compilation. Le serveur de production peut Ãªtre complÃ¨tement dÃ©couplÃ© de Vite, et le mÃªme setup peut Ãªtre facilement adaptÃ© pour permettre le prÃ©-rendu / la gÃ©nÃ©ration statique (_SSG_).

 Le rendu cÃ´tÃ© serveur de Vite est proposÃ© comme une fonctionnalitÃ© bas-niveau, et nous nous attendons Ã  ce que des frameworks plus haut-niveau sâ€™appuient dessus.

 ### Support sÃ©lectif des navigateurs plus anciens
diff --git a/guide/api-plugin.md b/guide/api-plugin.md
--- guide/api-plugin.md
+++ guide/api-plugin.md
@@ -1,7 +1,7 @@
 # API pour plugin

-Les plugins Vite Ã©tendent la trÃ¨s bonne interface pour plugin de Rollup avec quelques options spÃ©cifiques Ã  Vite. Lâ€™intÃ©rÃªt est que vous pouvez crÃ©er un seul plugin et quâ€™il fonctionnera Ã  la fois en dÃ©veloppement et pour le build.
+Les plugins Vite Ã©tendent la trÃ¨s bonne interface pour plugin de Rollup avec quelques options spÃ©cifiques Ã  Vite. Lâ€™intÃ©rÃªt est que vous pouvez crÃ©er un seul plugin et quâ€™il fonctionnera Ã  la fois en dÃ©veloppement et pour la compilation.

 **Il est recommandÃ© de lire [la documentation des plugins Rollup](https://rollupjs.org/guide/en/#plugin-development) (en anglais) avant ce qui suit.**

 ## CrÃ©er un plugin
@@ -108,9 +108,9 @@
 Voir lâ€™exemple de la [section suivante](#convention-pour-les-modules-virtuels).

 ## Convention pour les modules virtuels

-Les modules virtuels sont un procÃ©dÃ© utile qui permet de passer des informations aux fichiers source au moment du build avec une syntaxe dâ€™import de module ES normale.
+Les modules virtuels sont un procÃ©dÃ© utile qui permet de passer des informations aux fichiers source au moment de la compilation avec une syntaxe dâ€™import de module ES normale.

 ```js
 export default function myPlugin() {
   const virtualModuleId = '@my-virtual-module'
@@ -140,15 +140,15 @@

 console.log(msg)
 ```

-La convention de Vite pour les modules virtuels est de prÃ©fixer le chemin visible par lâ€™utilisateur par `virtual:`. Si possible le nom du plugin devrait Ãªtre utilisÃ© comme un namespace pour Ã©viter dâ€™entrer en conflit avec les autres plugins de lâ€™Ã©cosystÃ¨me. Par exemple, `vite-plugin-posts` pourrait demander aux utilisateurs dâ€™importer un module virtuel `virtual:posts` ou `virtual:posts/helpers` pour obtenir des informations au moment du build. En interne, les plugins qui utilisent des modules virtuels doivent prÃ©fixer lâ€™identifiant par `\0` lorsquâ€™ils rÃ©solvent lâ€™identifiant (câ€™est une convention de lâ€™Ã©cosystÃ¨me Rollup). Cela Ã©vite que dâ€™autres plugins essayent de traiter le mÃªme identifiant (comme la rÃ©solution des nÅ“uds), et les fonctionnalitÃ©s intÃ©grÃ©es Ã  Vite comme les sourcemaps peuvent se servir de cette information pour diffÃ©rencier les modules virtuels des fichiers classiques. `\0` nâ€™est pas un caractÃ¨re autorisÃ© dans les URLs dâ€™import alors nous devons le remplacer pendant lâ€™analyse de lâ€™import. Dans le navigateur, un identifiant virtuel `\0{id}` sera encodÃ© sous la forme `/@id/__x00__{id}` pour le dÃ©veloppement. Cet identifiant sera Ã  nouveau dÃ©codÃ© avant dâ€™entrer dans la pipeline de plugins, alors cette mÃ©canique nâ€™est pas visible par les hooks de plugins.
+La convention de Vite pour les modules virtuels est de prÃ©fixer le chemin visible par lâ€™utilisateur par `virtual:`. Si possible le nom du plugin devrait Ãªtre utilisÃ© comme un namespace pour Ã©viter dâ€™entrer en conflit avec les autres plugins de lâ€™Ã©cosystÃ¨me. Par exemple, `vite-plugin-posts` pourrait demander aux utilisateurs dâ€™importer un module virtuel `virtual:posts` ou `virtual:posts/helpers` pour obtenir des informations au moment de la compilation. En interne, les plugins qui utilisent des modules virtuels doivent prÃ©fixer lâ€™identifiant par `\0` lorsquâ€™ils rÃ©solvent lâ€™identifiant (câ€™est une convention de lâ€™Ã©cosystÃ¨me Rollup). Cela Ã©vite que dâ€™autres plugins essayent de traiter le mÃªme identifiant (comme la rÃ©solution des nÅ“uds), et les fonctionnalitÃ©s intÃ©grÃ©es Ã  Vite comme les sourcemaps peuvent se servir de cette information pour diffÃ©rencier les modules virtuels des fichiers classiques. `\0` nâ€™est pas un caractÃ¨re autorisÃ© dans les URLs dâ€™import alors nous devons le remplacer pendant lâ€™analyse de lâ€™import. Dans le navigateur, un identifiant virtuel `\0{id}` sera encodÃ© sous la forme `/@id/__x00__{id}` pour le dÃ©veloppement. Cet identifiant sera Ã  nouveau dÃ©codÃ© avant dâ€™entrer dans la pipeline de plugins, alors cette mÃ©canique nâ€™est pas visible par les hooks de plugins.

 Notez que les modules directement tirÃ©s dâ€™un vrai fichier, comme câ€™est le cas dâ€™un module de script dans un composant Ã  fichier unique (_SFC_) (un composant Ã  fichier unique .vue ou .svelte par exemple) nâ€™ont pas besoin de suivre cette convention. Les composants Ã  fichier unique gÃ©nÃ¨rent en gÃ©nÃ©ral une sÃ©rie de sous-modules lorsquâ€™ils sont traitÃ©s mais le code de ceux-ci peut-Ãªtre reliÃ© au systÃ¨me de fichiers. Utiliser `\0` pour ces sous-modules empÃªcherait les sourcemaps de fonctionner correctement.

 ## Hooks universels

-Pendant le dÃ©veloppement, le serveur de Vite crÃ©e un conteneur de plugin qui invoque les [hooks de build de Rollup](https://rollupjs.org/guide/en/#build-hooks) de la mÃªme faÃ§on que le fait Rollup.
+Pendant le dÃ©veloppement, le serveur de Vite crÃ©e un conteneur de plugin qui invoque les [hooks de compilation de Rollup](https://rollupjs.org/guide/en/#build-hooks) de la mÃªme faÃ§on que le fait Rollup.

 Les hooks suivants sont appelÃ©s une fois lors du dÃ©marrage du serveurâ€¯:

 - [`options`](https://rollupjs.org/guide/en/#options)
@@ -302,16 +302,16 @@
     }
   }
   ```

-  Notez que `configureServer` nâ€™est pas appelÃ© au moment du build de production alors vos autres hooks doivent gÃ©rer le cas oÃ¹ lâ€™instance de serveur est absente.
+  Notez que `configureServer` nâ€™est pas appelÃ© au moment de la compilation de production alors vos autres hooks doivent gÃ©rer le cas oÃ¹ lâ€™instance de serveur est absente.

 ### `transformIndexHtml`

 - **Typeâ€¯:** `IndexHtmlTransformHook | { enforce?: 'pre' | 'post', transform: IndexHtmlTransformHook }`
 - **Genreâ€¯:** `asynchrone`, `sÃ©quentiel`

-  Hook dÃ©diÃ© au fait de transformer `index.html`. Le hook reÃ§oit le HTML actuel sous la forme dâ€™une chaÃ®ne de caractÃ¨res et un contexte de transformation. Le contexte expose lâ€™instance du [`ViteDevServer`](./api-javascript#vitedevserver) pendant le dÃ©veloppement, et expose le bundle de sortie de Rollup pendant le build.
+  Hook dÃ©diÃ© au fait de transformer `index.html`. Le hook reÃ§oit le HTML actuel sous la forme dâ€™une chaÃ®ne de caractÃ¨res et un contexte de transformation. Le contexte expose lâ€™instance du [`ViteDevServer`](./api-javascript#vitedevserver) pendant le dÃ©veloppement, et expose le bundle de sortie de Rollup pendant la compilation.

   Le hook peut Ãªtre asynchrone et retourne un des formats suivantsâ€¯:

   - ChaÃ®ne de caractÃ¨res HTML transformÃ©e.
@@ -424,15 +424,15 @@
 - Alias.
 - Plugins utilisateur avec `enforce: 'pre'`.
 - Plugins internes Ã  Vite.
 - Plugins utilisateur sans valeur pour enforce.
-- Plugins de build de Vite.
+- Plugins de compilation de Vite.
 - Plugins utilisateur avec `enforce: 'post'`.
-- Plugins de build finaux de Vite (minification, manifeste, reporting).
+- Plugins de compilation finaux de Vite (minification, manifeste, reporting).

 ## Application conditionnelle

-Par dÃ©faut les plugins sont invoquÃ©s Ã  la fois pour serve et build. Dans les cas oÃ¹ un plugin ne doit Ãªtre appliquÃ© conditionnellement que pour serve ou build, utilisez la propriÃ©tÃ© `apply` pour seulement lâ€™invoquer durant `'build'` ou `'serve'`â€¯:
+Par dÃ©faut les plugins sont invoquÃ©s Ã  la fois pour `serve` et `build`. Dans les cas oÃ¹ un plugin ne doit Ãªtre appliquÃ© conditionnellement que pour serve ou `build`, utilisez la propriÃ©tÃ© `apply` pour seulement lâ€™invoquer durant `'build'` ou `'serve'`â€¯:

 ```js
 function myPlugin() {
   return {
@@ -445,9 +445,9 @@
 Un fonction peut aussi Ãªtre utilisÃ©e, pour plus de contrÃ´leâ€¯:

 ```js
 apply(config, { command }) {
-  // appliquer seulement pour le build et pas pour le rendu cÃ´tÃ© serveur
+  // appliquer seulement pour la compilation et pas pour le rendu cÃ´tÃ© serveur
   return command === 'build' && !config.build.ssr
 }
 ```

@@ -459,9 +459,9 @@

 - Il nâ€™utilise pas le hook [`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed).
 - Sa phase de bundling et sa phase dâ€™output sont dÃ©couplÃ©es.

-Si un plugin Rollup nâ€™a de sens que pour la phase de build, alors il peut Ãªtre spÃ©cifiÃ© sous `build.rollupOptions.plugins`.
+Si un plugin Rollup nâ€™a de sens que pour la phase de compilation, alors il peut Ãªtre spÃ©cifiÃ© sous `build.rollupOptions.plugins`.

 Vous pouvez aussi agrÃ©menter un plugin Rollup existant de propriÃ©tÃ©s propres Ã  Viteâ€¯:

 ```js
diff --git a/guide/assets.md b/guide/assets.md
--- guide/assets.md
+++ guide/assets.md
@@ -11,9 +11,9 @@
 import imgUrl from './img.png'
 document.getElementById('hero-img').src = imgUrl
 ```

-Par exemple, `imgUrl` sera `/img.png` pendant le dÃ©veloppement, et deviendra `/assets/img.2d8efhg.png` pour le build de production.
+Par exemple, `imgUrl` sera `/img.png` pendant le dÃ©veloppement, et deviendra `/assets/img.2d8efhg.png` pour la compilation de production.

 Le comportement est similaire au `file-loader` de webpack. La diffÃ©rence est que lâ€™import peut utiliser au choix un chemin absolu (par rapport Ã  la racine du projet pendant le dÃ©veloppement) ou un chemin relatif.

 - Les rÃ©fÃ©rences `url()` dans le CSS sont traitÃ©es de la mÃªme faÃ§on.
@@ -21,9 +21,9 @@
 - Si vous utilisez le plugin Vue, les rÃ©fÃ©rences Ã  des ressources dans le template dâ€™un composant Ã  fichier unique (_SFC_) sont convertis en imports.

 - Les types de fichiers les plus courants pour les images, les medias, ou les polices de caractÃ¨res sont dÃ©tectÃ©s automatiquement comme Ã©tant des ressources. Vous pouvez Ã©tendre la liste interne avec lâ€™[option `assetsInclude`](/config/#assetsinclude).

-- Les ressources rÃ©fÃ©rencÃ©es sont incluses au graphe des ressources du build, se voient assigner un nom de fichier hachÃ©, et peuvent Ãªtre transformÃ©es par des plugins dâ€™optimisation.
+- Les ressources rÃ©fÃ©rencÃ©es sont incluses au graphe des ressources de compilation, se voient assigner un nom de fichier hachÃ©, et peuvent Ãªtre transformÃ©es par des plugins dâ€™optimisation.

 - Les ressources plus petites (en octets) que lâ€™[option `assetsInlineLimit`](/config/#build-assetsinlinelimit) seront mises inline comme URLs de donnÃ©es base64.

 ### Imports URL explicites
@@ -47,9 +47,9 @@

 Les scripts peuvent Ãªtre importÃ©s en tant que web workers Ã  lâ€™aide des suffixes `?worker` et `?sharedworker`.

 ```js
-// il sera inclut Ã  un morceau (chunk) diffÃ©rent pour le build de production
+// il sera inclut Ã  un morceau (chunk) diffÃ©rent pour la compilation de production
 import Worker from './shader.js?worker'
 const worker = new Worker()
 ```

@@ -73,9 +73,9 @@
 - qui ne sont jamais rÃ©fÃ©rencÃ©es dans le code source (par exemple `robots.txt`),
 - qui doivent garder exactement le mÃªme nom de fichier (sans hachage),
 - â€¦ ou tout simplement que vous ne voulez pas avoir Ã  importer pour accÃ©der Ã  leur URL,

-alors vous pouvez les placer dans le rÃ©pertoire spÃ©cial `public` Ã  la racine de votre projet. Les ressources dans ce rÃ©pertoire seront servies Ã  la racine `/` pendant le dÃ©veloppement, et copiÃ©es Ã  la racine du rÃ©pertoire dist telles quelles lors du build.
+alors vous pouvez les placer dans le rÃ©pertoire spÃ©cial `public` Ã  la racine de votre projet. Les ressources dans ce rÃ©pertoire seront servies Ã  la racine `/` pendant le dÃ©veloppement, et copiÃ©es Ã  la racine du rÃ©pertoire `dist` telles quelles lors de la compilation.

 Le rÃ©pertoire par dÃ©faut est `<racine>/public`, mais cela peut-Ãªtre modifiÃ© Ã  lâ€™aide de lâ€™[option `publicDir`](/config/#publicdir).

 Notez queâ€¯:
@@ -102,9 +102,9 @@
   return new URL(`./dir/${name}.png`, import.meta.url).href
 }
 ```

-Pendant le build de production, Vite fera les transformations nÃ©cessaires pour que les URLs pointent toujours au bon endroit mÃªme aprÃ¨s le bundling et le hachage des ressources.
+Pendant la compilation de production, Vite fera les transformations nÃ©cessaires pour que les URLs pointent toujours au bon endroit mÃªme aprÃ¨s le bundling et le hachage des ressources.

 ::: warning Noteâ€¯: Ne fonctionne pas avec le rendu cÃ´tÃ© serveur (SSR)
 Ce pattern ne fonctionnera pas si vous utilisez Vite pour du rendu cÃ´tÃ© serveur, parce quâ€™`import.meta.url` a une sÃ©mantique diffÃ©rente dans le navigateur et dans Node.js. Le bundle serveur ne peut de toute faÃ§on pas dÃ©terminer lâ€™URL cliente en amont.
 :::
diff --git a/guide/backend-integration.md b/guide/backend-integration.md
--- guide/backend-integration.md
+++ guide/backend-integration.md
@@ -5,9 +5,9 @@

 Si vous avez besoin dâ€™une intÃ©gration particuliÃ¨re, vous pouvez suivre ce guide pour la configurer manuellement.
 :::

-1. Dans votre configuration Vite, configurez lâ€™entrÃ©e et activez le manifeste de buildâ€¯:
+1. Dans votre configuration Vite, configurez lâ€™entrÃ©e et activez le manifeste de compilation :

    ```js
    // vite.config.js
    export default defineConfig({
diff --git a/guide/build.md b/guide/build.md
--- guide/build.md
+++ guide/build.md
@@ -1,7 +1,7 @@
-# Build de production
+# Compilation de production

-Lorsquâ€™il est temps de dÃ©ployer votre application en production, lancez simplement la commande `vite build`. Par dÃ©faut, elle utilise `<racine>/index.html` comme point dâ€™entrÃ©e du build, et produit un bundle dâ€™application quâ€™il est possible de servir avec un service dâ€™hÃ©bergement statique. Vous pouvez retrouver des guides pour les services les plus populaires sur la page [DÃ©ployer un site statique](./static-deploy).
+Lorsquâ€™il est temps de dÃ©ployer votre application en production, lancez simplement la commande `vite build`. Par dÃ©faut, elle utilise `<racine>/index.html` comme point dâ€™entrÃ©e de compilation, et produit un bundle dâ€™application quâ€™il est possible de servir avec un service dâ€™hÃ©bergement statique. Vous pouvez retrouver des guides pour les services les plus populaires sur la page [DÃ©ployer un site statique](./static-deploy).

 ## CompatibilitÃ© navigateur

 Ce bundle de production part du principe que le JavaScript moderne est supportÃ©. Par dÃ©faut, Vite cible les navigateurs qui supportent les [balises script de modules ES natifs](https://caniuse.com/es6-module) et les [imports dynamiques de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Pour rÃ©fÃ©rence, Vite utilise cette requÃªte [browserslist](https://github.com/browserslist/browserslist)â€¯:
@@ -21,15 +21,15 @@
 - Voir aussiâ€¯: [Gestion des ressources statiques](./assets)

 Si vous dÃ©ployez votre projet sous un chemin public imbriquÃ©, spÃ©cifiez lâ€™[option de configuration `base`](/config/#base) et tous les chemins de ressources seront rÃ©Ã©cris en consÃ©quence. Cette option peut aussi Ãªtre spÃ©cifiÃ©e via lâ€™interface en ligne de commande, par exemple `vite build --base=/mon/chemin/public/`.

-Les URLs de ressources importÃ©es par le JavaScript, les rÃ©fÃ©rences `url()` dans le CSS, et les rÃ©fÃ©rences Ã  des ressources dans vos fichiers `.html` sont toutes ajustÃ©es automatiquement pour respecter cette option pendant le build.
+Les URLs de ressources importÃ©es par le JavaScript, les rÃ©fÃ©rences `url()` dans le CSS, et les rÃ©fÃ©rences Ã  des ressources dans vos fichiers `.html` sont toutes ajustÃ©es automatiquement pour respecter cette option pendant la compilation.

-La seule exception est quand vous devez concatÃ©ner dynamiquement des URLs Ã  la volÃ©e. Dans ce cas, utilisez la variable injectÃ©e globalement `import.meta.env.BASE_URL` qui contiendra le chemin public de base. Notez que cette variable est remplacÃ©e statiquement pendant le build alors elle doit apparaÃ®tre telle quelle (par exemple `import.meta.env['BASE_URL']` ne fonctionnera pas).
+La seule exception est quand vous devez concatÃ©ner dynamiquement des URLs Ã  la volÃ©e. Dans ce cas, utilisez la variable injectÃ©e globalement `import.meta.env.BASE_URL` qui contiendra le chemin public de base. Notez que cette variable est remplacÃ©e statiquement pendant la compilation alors elle doit apparaÃ®tre telle quelle (par exemple `import.meta.env['BASE_URL']` ne fonctionnera pas).

-## Customiser le build
+## Customiser la compilation

-Le build peut Ãªtre customisÃ© Ã  lâ€™aide de ses diverses [options de configuration](/config/#options-du-build). Plus spÃ©cifiquement, vous pouvez ajuster les [options du Rollup](https://rollupjs.org/guide/en/#big-list-of-options) sous-jacent avec `build.rollupOptions`â€¯:
+La compilation peut Ãªtre customisÃ© Ã  lâ€™aide de ses diverses [options de configuration](/config/#options-de-compilation). Plus spÃ©cifiquement, vous pouvez ajuster les [options du Rollup](https://rollupjs.org/guide/en/#big-list-of-options) sous-jacent avec `build.rollupOptions`â€¯:

 ```js
 // vite.config.js
 module.exports = defineConfig({
@@ -40,11 +40,11 @@
   }
 })
 ```

-Par exemple, vous pouvez spÃ©cifier plusieurs sorties Rollup Ã  lâ€™aide de plugins qui ne sont appliquÃ©s que pour le build.
+Par exemple, vous pouvez spÃ©cifier plusieurs sorties Rollup Ã  lâ€™aide de plugins qui ne sont appliquÃ©s que pour la compilation.

-## Refaire le build lorsque les fichiers sont modifiÃ©s
+## Refaire la compilation lorsque les fichiers sont modifiÃ©s

 Vous pouvez activer le watcher Rollup avec `vite build --watch`. Ou alors vous pouvez directement ajuster les [`WatcherOptions`](https://rollupjs.org/guide/en/#watch-options) dans `build.watch`â€¯:

 ```js
@@ -73,9 +73,9 @@
 ```

 Pendant la dÃ©veloppement, naviguez Ã  `/nested/` â€”â€¯cela fonctionne comme attendu, du moins dans le contexte dâ€™un serveur de fichiers statiques.

-Pour le build, tout ce que vous aurez Ã  faire est de spÃ©cifier plusieurs fichiers `.html` comme points dâ€™entrÃ©eâ€¯:
+Pour la compilation, tout ce que vous aurez Ã  faire est de spÃ©cifier plusieurs fichiers `.html` comme points dâ€™entrÃ©eâ€¯:

 ```js
 // vite.config.js
 const { resolve } = require('path')
@@ -119,9 +119,9 @@
       // bundle de votre librairie
       external: ['vue'],
       output: {
         // assurez-vous de fournir les variables globales Ã  utiliser dans le
-        // build UMD pour les dÃ©pendances externalisÃ©es
+        // compilation UMD pour les dÃ©pendances externalisÃ©es
         globals: {
           vue: 'Vue'
         }
       }
diff --git a/guide/comparisons.md b/guide/comparisons.md
--- guide/comparisons.md
+++ guide/comparisons.md
@@ -3,15 +3,15 @@
 ## Snowpack

 [Snowpack](https://www.snowpack.dev/) est aussi un serveur de dÃ©veloppement no-bundle reposant sur les bundles ES natifs qui est trÃ¨s similaire Ã  Vite en termes de pÃ©rimÃ¨tre. En dehors des dÃ©tails dâ€™implÃ©mentation qui diffÃ¨rent, les deux projets ont beaucoup en commun en termes dâ€™avantages techniques par rapport au tooling traditionnel. Le prÃ©-bundling des dÃ©pendances de Vite est aussi inspirÃ© de Snowpack v1 (qui est devenu [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Les plus grosses diffÃ©rences entre les deux projets sontâ€¯:

-**Build de production**
+**Compilation de production**

-La sortie de build par dÃ©faut de Snowpack nâ€™est pas un bundleâ€¯: il transforme chaque fichier en plusieurs modules buildÃ©s, qui peuvent ensuite Ãªtre passÃ©s Ã  diffÃ©rents Â«â€¯optimisateursâ€¯Â» (_"optimizers"_) qui sâ€™occupent du bundling. Lâ€™intÃ©rÃªt est que vous pouvez choisir entre diffÃ©rents bundlers finaux pour rÃ©pondre Ã  des besoins spÃ©cifiques (par exemple, webpack, Rollup, et mÃªme esbuild), et le cÃ´tÃ© pervers est que lâ€™expÃ©rience est relativement fragmentÃ©e â€”â€¯par exemple, lâ€™optimisateur esbuild est toujours instable, lâ€™optimisateur Rollup nâ€™est pas maintenu officiellement, et diffÃ©rents optimisateurs ne rendent pas la mÃªme chose en sortie et ne sont pas configurÃ©s de la mÃªme faÃ§on.
+La sortie de compilation par dÃ©faut de Snowpack nâ€™est pas un bundleâ€¯: il transforme chaque fichier en plusieurs modules compilatÃ©s, qui peuvent ensuite Ãªtre passÃ©s Ã  diffÃ©rents Â«â€¯optimisateursâ€¯Â» (_"optimizers"_) qui sâ€™occupent du bundling. Lâ€™intÃ©rÃªt est que vous pouvez choisir entre diffÃ©rents bundlers finaux pour rÃ©pondre Ã  des besoins spÃ©cifiques (par exemple, webpack, Rollup, et mÃªme esbuild), et le cÃ´tÃ© pervers est que lâ€™expÃ©rience est relativement fragmentÃ©e â€”â€¯par exemple, lâ€™optimisateur esbuild est toujours instable, lâ€™optimisateur Rollup nâ€™est pas maintenu officiellement, et diffÃ©rents optimisateurs ne rendent pas la mÃªme chose en sortie et ne sont pas configurÃ©s de la mÃªme faÃ§on.

-Vite choisit dâ€™avoir une intÃ©gration plus poussÃ©e dâ€™un seul bundler (Rollup) afin de fournir une expÃ©rience plus structurÃ©e. Cela permet aussi Ã  Vite de proposer une [API universelle pour plugin](./api-plugin) qui fonctionne Ã  la fois pour le dÃ©veloppement et pour le build.
+Vite choisit dâ€™avoir une intÃ©gration plus poussÃ©e dâ€™un seul bundler (Rollup) afin de fournir une expÃ©rience plus structurÃ©e. Cela permet aussi Ã  Vite de proposer une [API universelle pour plugin](./api-plugin) qui fonctionne Ã  la fois pour le dÃ©veloppement et pour la compilation.

-GrÃ¢ce au process de build plus intÃ©grÃ©, Vite supporte quelques fonctionnalitÃ©s qui ne sont pour lâ€™instant pas disponibles avec les optimisateurs de build de Snowpackâ€¯:
+GrÃ¢ce au process de compilation plus intÃ©grÃ©, Vite supporte quelques fonctionnalitÃ©s qui ne sont pour lâ€™instant pas disponibles avec les optimisateurs de compilation de Snowpackâ€¯:

 - [Support du multi-pages](./build#application-multi-pages)
 - [Mode librairie](./build#mode-librairie)
 - [Fractionnement (_code splitting_) automatique du CSS](./features#fractionnement-code-splitting-du-css)
@@ -43,7 +43,7 @@
 ## @web/dev-server

 [@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (autrefois `es-dev-server`) est un bon projet et le serveur basÃ© sur Koa de Vite 1.0 en est inspirÃ©.

-`@web/dev-server` est un peu plus bas-niveau en termes de pÃ©rimÃ¨tre. Il ne fournit pas dâ€™intÃ©grations officielles pour les frameworks, et requiert de configurer manuellement Rollup pour le build de production.
+`@web/dev-server` est un peu plus bas-niveau en termes de pÃ©rimÃ¨tre. Il ne fournit pas dâ€™intÃ©grations officielles pour les frameworks, et requiert de configurer manuellement Rollup pour la compilation de production.

 De maniÃ¨re gÃ©nÃ©rale, Vite est un outil plus _opinionated_ / haut-niveau et vise Ã  fournir des comportements par dÃ©faut qui conviennent la plupart du temps. Ceci Ã©tant dit, le projet `@web` contient beaucoup dâ€™autres outils qui sont excellents et qui peuvent aussi Ãªtre utiles pour les utilisateurs de Vite.
diff --git a/guide/dep-pre-bundling.md b/guide/dep-pre-bundling.md
--- guide/dep-pre-bundling.md
+++ guide/dep-pre-bundling.md
@@ -25,9 +25,9 @@
    ```

 2. **La performanceâ€¯:** Vite convertit les dÃ©pendances ESM ayant beaucoup de modules internes en un module unique pour amÃ©liorer la performance de chargement.

-   Certains packages fournissent leurs builds en modules ES sous la forme de plein de fichiers diffÃ©rents qui sâ€™importent les uns les autres. Par exemple, [`lodash-es` a plus de 600 modules internes](https://unpkg.com/browse/lodash-es/)â€¯! Lorsque lâ€™on Ã©crit `import { debounce } from 'lodash-es'`, le navigateur doit effectuer plus de 600 requÃªtes HTTP en mÃªme tempsâ€¯! MÃªme si le serveur peut les supporter, le grand nombre de requÃªtes crÃ©e un embouteillage du cÃ´tÃ© du navigateur, ce qui rend le chargement de la page nettement plus lent.
+   Certains packages fournissent leurs modules compilÃ©s sous format ES en plein de fichiers diffÃ©rents qui sâ€™importent les uns les autres. Par exemple, [`lodash-es` a plus de 600 modules internes](https://unpkg.com/browse/lodash-es/)â€¯! Lorsque lâ€™on Ã©crit `import { debounce } from 'lodash-es'`, le navigateur doit effectuer plus de 600 requÃªtes HTTP en mÃªme tempsâ€¯! MÃªme si le serveur peut les supporter, le grand nombre de requÃªtes crÃ©e un embouteillage du cÃ´tÃ© du navigateur, ce qui rend le chargement de la page nettement plus lent.

    En prÃ©-bundlant `lodash-es` en un unique module, il nâ€™y a plus besoin que dâ€™une requÃªte HTTPâ€¯!

 ## DÃ©couverte automatique des dÃ©pendances
@@ -40,10 +40,10 @@

 Dans une configuration monorepo, une dÃ©pendance peut Ãªtre un package liÃ© du mÃªme dÃ©pÃ´t. Vite dÃ©tecte automatiquement les dÃ©pendances qui ne sont pas rÃ©solues depuis `node_modules` et les traite comme du code source. Il nâ€™essaiera pas de bundler la dÃ©pendance liÃ©e, et analysera sa liste de dÃ©pendances Ã  la place.

 ::: warning Note
-Les dÃ©pendances liÃ©es peuvent ne pas fonctionner correctement dans le build final Ã  cause de diffÃ©rences dans la faÃ§on de rÃ©soudre les dÃ©pendances.
-Utilisez plutÃ´t `npm package` pour toutes les dÃ©pendances locales pour Ã©viter dâ€™avoir des problÃ¨mes dans le build final.
+Les dÃ©pendances liÃ©es peuvent ne pas fonctionner correctement dans la compilation final Ã  cause de diffÃ©rences dans la faÃ§on de rÃ©soudre les dÃ©pendances.
+Utilisez plutÃ´t `npm package` pour toutes les dÃ©pendances locales pour Ã©viter dâ€™avoir des problÃ¨mes dans la compilation finale.
 :::

 ## Modifier le comportement

diff --git a/guide/env-and-mode.md b/guide/env-and-mode.md
--- guide/env-and-mode.md
+++ guide/env-and-mode.md
@@ -95,9 +95,9 @@
 Dans votre application, vous pouvez rendre le titre en utilisant `import.meta.env.VITE_APP_TITLE`.

 Cependant, il est important de comprendre que le **mode** est un concept plus large que simplement dÃ©veloppement ou production. Un exemple typique est que vous pourriez vouloir disposer dâ€™un mode Â«â€¯stagingâ€¯Â» qui aurait un comportement similaire Ã  la production, mais avec des variables dâ€™environnement lÃ©gÃ¨rement diffÃ©rentes de celle-ci.

-Vous pouvez surcharger le mode utilisÃ© par dÃ©faut pour une commande en passant lâ€™option `--mode` en ligne de commande. Par exemple, si vous souhaitez builder votre app pour notre mode staging hypothÃ©tiqueâ€¯:
+Vous pouvez surcharger le mode utilisÃ© par dÃ©faut pour une commande en passant lâ€™option `--mode` en ligne de commande. Par exemple, si vous souhaitez compiler votre app pour notre mode staging hypothÃ©tiqueâ€¯:

 ```bash
 vite build --mode staging
 ```
diff --git a/guide/features.md b/guide/features.md
--- guide/features.md
+++ guide/features.md
@@ -29,9 +29,9 @@
 ## TypeScript

 Vite supporte lâ€™import de fichiers `.ts` par dÃ©faut.

-Vite ne fait que transpiler les fichiers `.ts` et nâ€™effectue **AUCUNE** vÃ©rification des types (_type checking_). Il part du principe que câ€™est votre IDE et votre process de build qui prennent en charge la vÃ©rification des types (vous pouvez lancer `tsc --noEmit` dans le script de build ou installer `vue-tsc` et lancer `vue-tsc --noEmit` pour effectuer la vÃ©rification des types de vos fichiers `*.vue`).
+Vite ne fait que transpiler les fichiers `.ts` et nâ€™effectue **AUCUNE** vÃ©rification des types (_type checking_). Il part du principe que câ€™est votre IDE et votre process de compilation qui prennent en charge la vÃ©rification des types (vous pouvez lancer `tsc --noEmit` dans le script de compilation ou installer `vue-tsc` et lancer `vue-tsc --noEmit` pour effectuer la vÃ©rification des types de vos fichiers `*.vue`).

 Vite utilise [esbuild](https://github.com/evanw/esbuild) pour transpiler le TypeScript en JavaScript, ce qui est environ 20 Ã  30 fois plus rapide quâ€™avec `tsc`, et les remplacements de modules peuvent Ãªtre faits en moins de 50â€¯ms.

 Utilisez la syntaxe dâ€™[imports et dâ€™export des types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) pour Ã©viter dâ€™Ã©ventuels problÃ¨mes comme les imports de types qui seraient mal bundlÃ©s. Par exempleâ€¯:
@@ -65,9 +65,9 @@
 La plupart des librairies prÃ©sument que `"useDefineForClassFields": true`, comme [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties) par exemple, ou [Vue Class Components 8.x](https://github.com/vuejs/vue-class-component/issues/465).

 Mais certaines dâ€™entre elles nâ€™ont pas encore fait la transition, comme [`lit-element`](https://github.com/lit/lit-element/issues/1030). DÃ©finissez explicitement `useDefineForClassFields` Ã  `false` dans ces cas-lÃ .

-#### Autres options du compilateur qui affectent le rÃ©sultat du build
+#### Autres options du compilateur qui affectent le rÃ©sultat de la compilation

 - [`extends`](https://www.typescriptlang.org/tsconfig#extends)
 - [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)
 - [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)
@@ -235,9 +235,9 @@
 ```

 ```js
 // charge un web worker qui est mis inline en chaÃ®ne de caractÃ¨res base64 au
-// moment du build
+// moment de la compilation
 import InlineWorker from './worker.js?worker&inline'
 ```

 Plus de dÃ©tails sur la page [Gestion des ressources statiques](./assets).
@@ -281,9 +281,9 @@
   })
 }
 ```

-Les fichiers correspondants sont chargÃ©s de maniÃ¨re opportune (_lazy loaded_) Ã  lâ€™aide de lâ€™import dynamique et seront sÃ©parÃ©s en diffÃ©rents morceaux (_chunks_) durant le build. Si vous prÃ©fÃ©rez importer tous les modules directement (par exemple si vous avez besoin que des effets secondaires (_side-effects_) de ces modules soient dâ€™abord appliquÃ©s), vous pouvez utiliser plutÃ´t `import.meta.globEager`â€¯:
+Les fichiers correspondants sont chargÃ©s de maniÃ¨re opportune (_lazy loaded_) Ã  lâ€™aide de lâ€™import dynamique et seront sÃ©parÃ©s en diffÃ©rents morceaux (_chunks_) durant la compilation. Si vous prÃ©fÃ©rez importer tous les modules directement (par exemple si vous avez besoin que des effets secondaires (_side-effects_) de ces modules soient dâ€™abord appliquÃ©s), vous pouvez utiliser plutÃ´t `import.meta.globEager`â€¯:

 ```js
 const modules = import.meta.globEager('./dir/*.js')
 ```
@@ -333,9 +333,9 @@
   /* ... */
 })
 ```

-Dans le build de production, les fichiers `.wasm` qui sont plus petits que `assetInlineLimit` seront mis inline en tant que chaÃ®nes de caractÃ¨res base64. Sinon, ils seront copiÃ©s dans le dossier dist comme des ressources et seront rÃ©cupÃ©rÃ©s Ã  la demande.
+Dans la compilation de production, les fichiers `.wasm` qui sont plus petits que `assetInlineLimit` seront mis inline en tant que chaÃ®nes de caractÃ¨res base64. Sinon, ils seront copiÃ©s dans le dossier dist comme des ressources et seront rÃ©cupÃ©rÃ©s Ã  la demande.

 ## Web workers

 Un script web worker peut Ãªtre importÃ© directement en suffixant `?worker` ou `?sharedworker` Ã  la requÃªte dâ€™import. Par dÃ©faut, lâ€™export sera un constructeur de workerâ€¯:
@@ -345,19 +345,19 @@

 const worker = new MyWorker()
 ```

-Le script de worker peut aussi Ãªtre une dÃ©claration `import` plutÃ´t quâ€™`importScripts()` â€”â€¯notez que durant le dÃ©veloppement cela repose sur le support natif et ne fonctionne actuellement quâ€™avec Chrome, mais pour le build de production il sera compilÃ©.
+Le script de worker peut aussi Ãªtre une dÃ©claration `import` plutÃ´t quâ€™`importScripts()` â€”â€¯notez que durant le dÃ©veloppement cela repose sur le support natif et ne fonctionne actuellement quâ€™avec Chrome, mais pour la compilation de production il sera compilÃ©.

-Par dÃ©faut, le script du worker sera Ã©mis dans un morceau (_chunk_) diffÃ©rent dans le build de production. Si vous souhaitez mettre le worker inline dans des chaÃ®nes de caractÃ¨res base64, ajoutez lâ€™instruction `inline`â€¯:
+Par dÃ©faut, le script du worker sera Ã©mis dans un morceau (_chunk_) diffÃ©rent dans la compilation de production. Si vous souhaitez mettre le worker inline dans des chaÃ®nes de caractÃ¨res base64, ajoutez lâ€™instruction `inline`â€¯:

 ```js
 import MyWorker from './worker?worker&inline'
 ```

-## Optimisations du build
+## Optimisations de la compilation

-> Les fonctionnalitÃ©s ci-dessous sont appliquÃ©es automatiquement lors du process de build et il nâ€™y a pas besoin de les configurer explicitement, Ã  moins que vous ne vouliez les dÃ©sactiver.
+> Les fonctionnalitÃ©s ci-dessous sont appliquÃ©es automatiquement lors du process de compilation et il nâ€™y a pas besoin de les configurer explicitement, Ã  moins que vous ne vouliez les dÃ©sactiver.

 ### Fractionnement (_code splitting_) du CSS

 Vite extrait automatiquement le CSS utilisÃ© par les modules dans un morceau (_chunk_) asynchrone et gÃ©nÃ¨re un fichier sÃ©parÃ©. Le fichier CSS est automatiquement chargÃ© via une balise `<link>` quand le morceau asynchrone associÃ© est chargÃ©, et le morceau asynchrone nâ€™est Ã©valuÃ© quâ€™aprÃ¨s le chargement du CSS pour Ã©viter les [FOUCs](https://fr.wikipedia.org/wiki/FOUC).
diff --git a/guide/index.md b/guide/index.md
--- guide/index.md
+++ guide/index.md
@@ -5,25 +5,25 @@
 </audio>

 ## Vue dâ€™ensemble

-Vite (prononcÃ© comme en franÃ§ais<button style="border:none;padding:3px;border-radius:4px" id="play-vite-audio" onclick="document.getElementById('vite-audio').play();"><img src="/voice.svg" height="15"></button>) est un outil de build qui vise Ã  proposer une expÃ©rience de dÃ©veloppement plus rapide et lÃ©gÃ¨re pour les projets web modernes. Il se dÃ©coupe en deux grandes partiesâ€¯:
+Vite (prononcÃ© comme en franÃ§ais<button style="border:none;padding:3px;border-radius:4px" id="play-vite-audio" onclick="document.getElementById('vite-audio').play();"><img src="/voice.svg" height="15"></button>) est un outil de compilation qui vise Ã  proposer une expÃ©rience de dÃ©veloppement plus rapide et lÃ©gÃ¨re pour les projets web modernes. Il se dÃ©coupe en deux grandes partiesâ€¯:

 - Un serveur de dÃ©veloppement qui propose de [nombreuses fonctionnalitÃ©s](./features) Ã  travers les [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules), y compris un [rafraÃ®chissement des modules Ã  la volÃ©e (_HMR_)](./features#rafraichissement-des-modules-a-la-volee-hmr) ultra rapide.

-- Une commande de build qui bundle votre code Ã  lâ€™aide de [Rollup](https://rollupjs.org), qui est prÃ©-configurÃ© pour optimiser grandement la taille des ressources statiques en production.
+- Une commande de compilation qui bundle votre code Ã  lâ€™aide de [Rollup](https://rollupjs.org), qui est prÃ©-configurÃ© pour optimiser grandement la taille des ressources statiques en production.

 Vite est Â«â€¯_opinionated_â€¯Â» et propose certains comportements par dÃ©faut qui conviendront dans la plupart des cas, et il est aussi possible de lâ€™Ã©tendre grÃ¢ce Ã  son [API pour plugin](./api-plugin) et son [API JavaScript](./api-javascript).

 Vous pouvez en apprendre plus sur les raisons qui motivent le projet sur la page [Pourquoi utiliser Viteâ€¯?](./why).

 ## Support navigateur

-- La configuration par dÃ©faut cible les navigateurs qui supportent Ã  la fois les [modules ES natifs Ã  travers les balises script](https://caniuse.com/es6-module) et lâ€™[import dynamique de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Les navigateurs antÃ©rieurs peuvent Ãªtre supportÃ©s Ã  lâ€™aide du plugin officiel [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) â€”â€¯voir la page [Build de production](./build) pour plus de dÃ©tails.
+- La configuration par dÃ©faut cible les navigateurs qui supportent Ã  la fois les [modules ES natifs Ã  travers les balises script](https://caniuse.com/es6-module) et lâ€™[import dynamique de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Les navigateurs antÃ©rieurs peuvent Ãªtre supportÃ©s Ã  lâ€™aide du plugin officiel [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) â€”â€¯voir la page [Compilation de production](./build) pour plus de dÃ©tails.

 ## Essayer Vite en ligne

-Vous pouvez essayer Vite en ligne sur [StackBlitz](https://vite.new/). Le site exÃ©cute une configuration de build basÃ©e sur Vite directement dans le navigateur, alors lâ€™expÃ©rience est quasiment la mÃªme quâ€™en local, sans avoir besoin dâ€™installer quoi que ce soit sur votre machine. Vous pouvez naviguer sur `vite.new/{template}` pour utiliser un framework.
+Vous pouvez essayer Vite en ligne sur [StackBlitz](https://vite.new/). Le site exÃ©cute une configuration de compilation basÃ©e sur Vite directement dans le navigateur, alors lâ€™expÃ©rience est quasiment la mÃªme quâ€™en local, sans avoir besoin dâ€™installer quoi que ce soit sur votre machine. Vous pouvez naviguer sur `vite.new/{template}` pour utiliser un framework.

 Les templates supportÃ©s sontâ€¯:

 |             JavaScript              |                TypeScript                 |
@@ -120,19 +120,19 @@
 {
   "scripts": {
     "dev": "vite", // dÃ©marre le serveur de dÃ©veloppement
                    // aliasâ€¯: `vite dev`, `vite serve`
-    "build": "vite build",    // effectue le build de production
-    "preview": "vite preview" // prÃ©visualise le build de production en local
+    "build": "vite build",    // effectue la compilation de production
+    "preview": "vite preview" // prÃ©visualise la compilation de production en local
   }
 }
 ```

 Des options de ligne de commande supplÃ©mentaires comme `--port` ou `--https` sont disponibles. Vous pouvez en voir la liste en lanÃ§ant `npx vite --help` dans votre projet.

 ## Utiliser des commits inÃ©dits

-Si vous voulez tester les derniÃ¨res fonctionnalitÃ©s sans attendre de nouvelle version, vous devrez cloner le [dÃ©pÃ´t vite](https://github.com/vitejs/vite) sur votre machine, le builder et le lier (_link_) vous-mÃªme ([pnpm](https://pnpm.io/) doit Ãªtre installÃ©)â€¯:
+Si vous voulez tester les derniÃ¨res fonctionnalitÃ©s sans attendre de nouvelle version, vous devrez cloner le [dÃ©pÃ´t vite](https://github.com/vitejs/vite) sur votre machine, le compiler et le lier (_link_) vous-mÃªme ([pnpm](https://pnpm.io/) doit Ãªtre installÃ©)â€¯:

 ```bash
 git clone https://github.com/vitejs/vite.git
 cd vite
diff --git a/guide/migration.md b/guide/migration.md
--- guide/migration.md
+++ guide/migration.md
@@ -11,9 +11,9 @@
 - `jsx` et `enableEsbuild` ont Ã©tÃ© retirÃ©esâ€¯; utilisez plutÃ´t la nouvelle [option `esbuild`](/config/#esbuild).

 - Les [options en lien avec le CSS](/config/#css-modules) sont dÃ©sormais regroupÃ©es sous `css`.

-- Toutes les [options spÃ©cifiques au build](/config/#options-du-build) sont dÃ©sormais regroupÃ©es sous `build`.
+- Toutes les [options spÃ©cifiques Ã  la compilation](/config/#options-de-compilation) sont dÃ©sormais regroupÃ©es sous `build`.

   - `rollupInputOptions` et `rollupOutputOptions` sont remplacÃ©es par [`build.rollupOptions`](/config/#build-rollupoptions).
   - `esbuildTarget` est dÃ©sormais [`build.target`](/config/#build-target).
   - `emitManifest` est dÃ©sormais [`build.manifest`](/config/#build-manifest).
@@ -97,9 +97,9 @@
 `import.meta.hot.acceptDeps()` est dÃ©sormais dÃ©prÃ©ciÃ©. [`import.meta.hot.accept()`](./api-hmr#hot-accept-deps-cb) accepte dÃ©sormais une ou plusieurs dÃ©pendances.

 ## Changements du format du manifeste

-Le manifeste du build utilise dÃ©sormais le format suivantâ€¯:
+Le manifeste de compilation utilise dÃ©sormais le format suivantâ€¯:

 ```json
 {
   "index.js": {
diff --git a/guide/ssr.md b/guide/ssr.md
--- guide/ssr.md
+++ guide/ssr.md
@@ -153,14 +153,14 @@
 +   "dev": "node server"
   }
 ```

-## Build de production
+## Compilation de production

 Pour mettre en production un projet usant du rendu cÃ´tÃ© serveur, on doitâ€¯:

-1. Produire un build client normal, et
-2. Produire un build de rendu cÃ´tÃ© serveur, qui peut Ãªtre chargÃ© directement par `require()` afin que lâ€™on nâ€™ait pas besoin de repasser dans le `ssrLoadModule` de Vite.
+1. Produire une compilation client normal, et
+2. Produire une compilation de rendu cÃ´tÃ© serveur, qui peut Ãªtre chargÃ© directement par `require()` afin que lâ€™on nâ€™ait pas besoin de repasser dans le `ssrLoadModule` de Vite.

 Les scripts de `package.json` ressembleront Ã  Ã§aâ€¯:

 ```json
@@ -172,30 +172,30 @@
   }
 }
 ```

-Notez que le signal `--ssr` indique quâ€™il sâ€™agit dâ€™un build de rendu cÃ´tÃ© serveur. Il devrait Ã©galement indiquer lâ€™entrÃ©e de rendu cÃ´tÃ© serveur.
+Notez que le signal `--ssr` indique quâ€™il sâ€™agit dâ€™une compilation de rendu cÃ´tÃ© serveur. Il devrait Ã©galement indiquer lâ€™entrÃ©e de rendu cÃ´tÃ© serveur.

 Ensuite, dans `server.js`, on doit ajouter de la logique spÃ©cifique Ã  la production en se rÃ©fÃ©rant Ã  `process.env.NODE_ENV`â€¯:

-- Au lieu de lire le `index.html` racine, utilisez plutÃ´t `dist/client/index.html` comme template, puisquâ€™il contient les bons liens vers les ressources pour le build client.
+- Au lieu de lire le `index.html` racine, utilisez plutÃ´t `dist/client/index.html` comme template, puisquâ€™il contient les bons liens vers les ressources pour la compilation client.

-- Au lieu dâ€™`await vite.ssrLoadModule('/src/entry-server.js')`, utilisez plutÃ´t `require('./dist/server/entry-server.js')` (ce fichier est le rÃ©sultat du build de rendu cÃ´tÃ© serveur).
+- Au lieu dâ€™`await vite.ssrLoadModule('/src/entry-server.js')`, utilisez plutÃ´t `require('./dist/server/entry-server.js')` (ce fichier est le rÃ©sultat de la compilation de rendu cÃ´tÃ© serveur).

 - DÃ©placez la crÃ©ation et tous les usages du serveur du dÃ©veloppement `vite` derriÃ¨re des branches conditionnelles spÃ©cifiques au dÃ©veloppement, et ajoutez des middlewares servant les fichiers statiques de `dist/client`.

 RÃ©fÃ©rez-vous aux dÃ©monstrations pour [Vue](https://github.com/vitejs/vite/tree/main/packages/playground/ssr-vue) et [React](https://github.com/vitejs/vite/tree/main/packages/playground/ssr-react) si vous avez besoin dâ€™un exemple de configuration qui fonctionne.

 ## GÃ©nÃ©rer les directives de prÃ©-chargement (_preload directives_)

-`vite build` supporte le signal `--ssrManifest` qui gÃ©nÃ©rera un fichier `ssr-manifest.json` dans le rÃ©pertoire de sortie du buildâ€¯:
+`vite build` supporte le signal `--ssrManifest` qui gÃ©nÃ©rera un fichier `ssr-manifest.json` dans le rÃ©pertoire de sortie de la compilation:

 ```diff
 - "build:client": "vite build --outDir dist/client",
 + "build:client": "vite build --outDir dist/client --ssrManifest",
 ```

-Le script ci-dessus gÃ©nÃ©rera dÃ©sormais un fichier `dist/client/ssr-manifest.json` pour le build client â€”â€¯oui, le manifeste de rendu cÃ´tÃ© serveur est gÃ©nÃ©rÃ© depuis le build client car nous voulons associer les identifiants de modules aux fichiers clients. Le manifeste contient des associations entre les identifiants de modules et les morceaux (_chunks_) ou les fichiers de ressources correspondants.
+Le script ci-dessus gÃ©nÃ©rera dÃ©sormais un fichier `dist/client/ssr-manifest.json` pour la compilation client â€”â€¯oui, le manifeste de rendu cÃ´tÃ© serveur est gÃ©nÃ©rÃ© depuis la compilation client car nous voulons associer les identifiants de modules aux fichiers clients. Le manifeste contient des associations entre les identifiants de modules et les morceaux (_chunks_) ou les fichiers de ressources correspondants.

 Pour exploiter le manifeste, les frameworks doivent fournir un moyen de collecter les identifiants des modules des composants qui ont Ã©tÃ© utilisÃ©s durant le rendu cÃ´tÃ© serveur.

 `@vitejs/plugin-vue` intÃ¨gre ce processus et inscrit automatiquement les identifiants des modules utilisÃ©s pour les composants sur le contexte de rendu cÃ´tÃ© serveur de Vue associÃ©â€¯:
@@ -215,19 +215,19 @@
 Si les routes et les donnÃ©es requises pour certaines routes sont connues Ã  lâ€™avance, on peut prÃ©-rendre ces routes en HTML statique en usant de la mÃªme logique que pour le rendu cÃ´tÃ© serveur de production. Cela peut-Ãªtre considÃ©rÃ© comme une forme de gÃ©nÃ©ration cÃ´tÃ© serveur. Voir [le script de prÃ©-rendu de dÃ©monstration](https://github.com/vitejs/vite/blob/main/packages/playground/ssr-vue/prerender.js) pour un exemple qui fonctionne.

 ## Externalisation

-De nombreuses dÃ©pendances fournissent Ã  la fois des fichiers de modules ES et CommonJS. Une dÃ©pendance fournissant un build CommonJS peut Ãªtre Â«â€¯externalisÃ©eâ€¯Â» de la transformation et du systÃ¨me de modules de rendu cÃ´tÃ© serveur de Vite lorsque le rendu cÃ´tÃ© serveur est utilisÃ©, afin de rendre Ã  la fois le serveur de dÃ©veloppement et le build plus rapides. Par exemple, plutÃ´te que de tirer la version modules ES de React et dâ€™ensuite la re-transformer pour quâ€™elle soit compatible avec Node.js, il est plus efficace de simplement `require('react')`. Cela raccourcit aussi grandement la durÃ©e du build de rendu cÃ´tÃ© serveur.
+De nombreuses dÃ©pendances fournissent Ã  la fois des fichiers de modules ES et CommonJS. Une dÃ©pendance fournissant une compilation CommonJS peut Ãªtre Â«â€¯externalisÃ©eâ€¯Â» de la transformation et du systÃ¨me de modules de rendu cÃ´tÃ© serveur de Vite lorsque le rendu cÃ´tÃ© serveur est utilisÃ©, afin de rendre Ã  la fois le serveur de dÃ©veloppement et la compilation plus rapides. Par exemple, plutÃ´te que de tirer la version modules ES de React et dâ€™ensuite la re-transformer pour quâ€™elle soit compatible avec Node.js, il est plus efficace de simplement `require('react')`. Cela raccourcit aussi grandement la durÃ©e de compilation de rendu cÃ´tÃ© serveur.

 Vite rÃ©alise lâ€™externalisation du rendu cÃ´tÃ© serveur automatiquement selon les heuristiques suivantesâ€¯:

-- Si le point dâ€™entrÃ©e de module ES rÃ©solu et son point dâ€™entrÃ©e par dÃ©faut pour Node sont diffÃ©rents, le point dâ€™entrÃ©e pour Node est probablement un build CommonJS qui peut Ãªtre externalisÃ©. Par exemple, `vue` sera externalisÃ© automatiquement car il fournit Ã  la fois un build module ES et un build CommonJS.
+- Si le point dâ€™entrÃ©e de module ES rÃ©solu et son point dâ€™entrÃ©e par dÃ©faut pour Node sont diffÃ©rents, le point dâ€™entrÃ©e pour Node est probablement une compilation CommonJS qui peut Ãªtre externalisÃ©. Par exemple, `vue` sera externalisÃ© automatiquement car il fournit Ã  la fois une compilation en module ES et une compilation en CommonJS.

 - Sinon, Vite regardera si le point dâ€™entrÃ©e du package contient de la syntaxe de modules ES valide â€”â€¯si ce nâ€™est pas le cas, le package est probablement au format CommonJS et sera externalisÃ©. Par exemple, `react-dom` sera externalisÃ© automatiquement car il ne spÃ©cifie quâ€™une entrÃ©e et quâ€™elle est au format CommonJS.

 Si les heuristiques mÃ¨nent Ã  des erreurs, vous pouvez ajuster manuellement lâ€™externalisation du rendu cÃ´tÃ© serveur Ã  lâ€™aide des options de configuration `ssr.external` et `ssr.noExternal`.

-Dans le futur, ces heuristiques seront sans doute meilleures si le projet a le `type: "module"` dâ€™activÃ©, afin que Vite puisse aussi externaliser les dÃ©pendances qui fournissent des builds ESM compatibles avec Node en les important avec `import()` pendant le rendu cÃ´tÃ© serveur.
+Dans le futur, ces heuristiques seront sans doute meilleures si le projet a le `type: "module"` dâ€™activÃ©, afin que Vite puisse aussi externaliser les dÃ©pendances qui fournissent des compilation ESM compatibles avec Node en les important avec `import()` pendant le rendu cÃ´tÃ© serveur.

 :::warning GÃ©rer les alias
 Si vous avez configurÃ© des alias qui redirigent un package vers un autre, vous pourriez plutÃ´t vouloir faire des alias des vÃ©ritables packages `node_modules` afin que cela fonctionne pour les dÃ©pendances externalisÃ©es pour le rendu cÃ´tÃ© serveur. [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) et [pnpm](https://pnpm.js.org/en/aliases) supportent tous deux les alias via le prÃ©fixe `npm:`.
 :::
@@ -262,12 +262,12 @@
 :::

 ## Cible de rendu cÃ´tÃ© serveur

-La cible par dÃ©faut du build de rendu cÃ´tÃ© serveur est un environnement Node, mais vous pouvez Ã©galement exÃ©cuter le serveur dans un web worker. La diffÃ©rence rÃ©side dans la rÃ©solution de lâ€™entrÃ©e du package qui est diffÃ©rente suivant la plateforme. Vous pouvez configurer la cible pour quâ€™elle soit un web worker en dÃ©finissant `ssr.target` sur `'webworker'`.
+La cible par dÃ©faut de compilation de rendu cÃ´tÃ© serveur est un environnement Node, mais vous pouvez Ã©galement exÃ©cuter le serveur dans un web worker. La diffÃ©rence rÃ©side dans la rÃ©solution de lâ€™entrÃ©e du package qui est diffÃ©rente suivant la plateforme. Vous pouvez configurer la cible pour quâ€™elle soit un web worker en dÃ©finissant `ssr.target` sur `'webworker'`.

 ## Bundle de rendu cÃ´tÃ© serveur

-Dans certains cas, comme lorsque le runtime est `webworker`, il se peut que vous souhaitiez que votre build de rendu cÃ´tÃ© serveur soit bundlÃ© en un seul fichier JavaScript. Vous pouvez obtenir ce comportement en dÃ©finissant `ssr.noExternal` Ã  `true`. Cela aura deux effetsâ€¯:
+Dans certains cas, comme lorsque le runtime est `webworker`, il se peut que vous souhaitiez que votre compilation de rendu cÃ´tÃ© serveur soit bundlÃ© en un seul fichier JavaScript. Vous pouvez obtenir ce comportement en dÃ©finissant `ssr.noExternal` Ã  `true`. Cela aura deux effetsâ€¯:

 - Toutes les dÃ©pendances seront traitÃ©es comme `noExternal`
 - Une erreur sera dÃ©clenchÃ©e si une fonctionnalitÃ© intÃ©grÃ©e Ã  Node.js est importÃ©e
diff --git a/guide/static-deploy.md b/guide/static-deploy.md
--- guide/static-deploy.md
+++ guide/static-deploy.md
@@ -14,34 +14,34 @@
   }
 }
 ```

-Il est important de noter que `vite preview` est fait pour prÃ©visualiser le build localement et pas pour Ãªtre un serveur de production.
+Il est important de noter que `vite preview` est fait pour prÃ©visualiser la compilation localement et pas pour Ãªtre un serveur de production.

 ::: tip NOTE
 Ces guides fournissent des instructions pour effectuer un dÃ©ploiement statique de votre site Vite. Vite propose Ã©galement un support expÃ©rimental du rendu cÃ´tÃ© serveur (_server side rendering_). Le rendu cÃ´tÃ© serveur fait rÃ©fÃ©rence aux frameworks front-end qui supportent le fait dâ€™exÃ©cuter une application dans Node.js, qui font un prÃ©-rendu en HTML, et qui lâ€™Â«â€¯hydratentâ€¯Â» cÃ´tÃ© client en bout de course. Allez voir le [guide du rendu cÃ´tÃ© serveur](./ssr) pour en savoir plus sur cette fonctionnalitÃ©. Autrement, si vous souhaitez intÃ©grer votre application Ã  un framework cÃ´tÃ© serveur classique, allez plutÃ´t voir le [guide dâ€™intÃ©gration du back-end](./backend-integration).
 :::

-## Builder lâ€™application
+## Compiler lâ€™application

-Vous pouvez lancer la commande `npm run build` pour builder lâ€™application.
+Vous pouvez lancer la commande `npm run build` pour compiler lâ€™application.

 ```bash
 $ npm run build
 ```

-Par dÃ©faut, la sortie du build sera placÃ©e dans `dist`. Vous pouvez dÃ©ployer ce dossier `dist` Ã  lâ€™aide de la plateforme de votre choix.
+Par dÃ©faut, la sortie de compilation sera placÃ©e dans `dist`. Vous pouvez dÃ©ployer ce dossier `dist` Ã  lâ€™aide de la plateforme de votre choix.

 ### Tester lâ€™application localement

-Une fois que vous avez buildÃ© lâ€™application, vous pouvez la tester localement avec la commande `npm run preview`.
+Une fois que vous avez compilÃ© lâ€™application, vous pouvez la tester localement avec la commande `npm run preview`.

 ```bash
 $ npm run build
 $ npm run preview
 ```

-La commande `vite preview` va dÃ©marrer un serveur web statique local qui sert les fichiers du dossier `dist` sur `http://localhost:4173`. Câ€™est un moyen facile de vÃ©rifier que le build de production fonctionne en local.
+La commande `vite preview` va dÃ©marrer un serveur web statique local qui sert les fichiers du dossier `dist` sur `http://localhost:4173`. Câ€™est un moyen facile de vÃ©rifier que la compilation de production fonctionne en local.

 Vous pouvez configurer le port du serveur en passant lâ€™option `--port` comme argument.

 ```json
@@ -69,12 +69,12 @@

    # annuler sâ€™il y a une erreur
    set -e

-   # build
+   # compilation
    npm run build

-   # naviguer au rÃ©pertoire de sortie du build
+   # naviguer au rÃ©pertoire de sortie de compilation
    cd dist

    # si vous dÃ©ployez vers un domaine personnalisÃ©
    # echo 'www.example.com' > CNAME
@@ -138,9 +138,9 @@
    Si vous dÃ©ployez sur `https://<NOM Dâ€™UTILISATEUR ou GROUPE>.gitlab.io/`, vous pouvez omettre `base` puisque la valeur par dÃ©faut est `'/'`.

    Si vous dÃ©polyez sur `https://<NOM Dâ€™UTILISATEUR ou GROUPE>.gitlab.io/<DÃ‰PÃ”T>/`, par exemple si lâ€™adresse de votre dÃ©pÃ´t est `https://gitlab.com/<NOM Dâ€™UTILISATEUR>/<DÃ‰PÃ”T>`, alors dÃ©finissez `base` Ã  `'/<DÃ‰PÃ”T>/'`.

-2. CrÃ©ez un fichier nommÃ© `.gitlab-ci.yml` Ã  la racine de votre projet avec le contenu ci-dessous. Cela va builder et dÃ©ployer votre site chaque fois que vous en modifiez le contenuâ€¯:
+2. CrÃ©ez un fichier nommÃ© `.gitlab-ci.yml` Ã  la racine de votre projet avec le contenu ci-dessous. Cela va compiler et dÃ©ployer votre site chaque fois que vous en modifiez le contenuâ€¯:

    ```yaml
    image: node:16.5.0
    pages:
@@ -315,7 +315,7 @@
 - De lâ€™[extension SWA](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) pour [Visual Studio Code](https://code.visualstudio.com).

 Installez lâ€™extension sur VS Code et naviguez Ã  la racine de votre application. Ouvrez lâ€™extension, connectez-vous Ã  Azure, et cliquez sur le signe Â«â€¯+â€¯Â» pour crÃ©er une nouvelle Static Web App. On vous demandera quelle clÃ© de souscription utiliser.

-Suivez les instructions de lâ€™extension pour donner un nom Ã  votre application, choisissez un preset de framework, et donnez la racine de lâ€™application (le plus souvent `/`) ainsi que lâ€™emplacement des fichiers buildÃ©s `/dist`. Une action GitHub sera crÃ©Ã©e dans votre dÃ©pÃ´t dans un dossier `.github`.
+Suivez les instructions de lâ€™extension pour donner un nom Ã  votre application, choisissez un preset de framework, et donnez la racine de lâ€™application (le plus souvent `/`) ainsi que lâ€™emplacement des fichiers compilÃ©s `/dist`. Une action GitHub sera crÃ©Ã©e dans votre dÃ©pÃ´t dans un dossier `.github`.

 Lâ€™action dÃ©ploiera votre application (vous pouvez suivre la progression dans lâ€™onglet Actions de votre dÃ©pÃ´t) et, lorsque le process rÃ©ussit, vous permettra de voir votre application Ã  lâ€™adresse fournie en cliquant sur le bouton Â«â€¯Browse Websiteâ€¯Â» de la fenÃªtre de progression de lâ€™extension, qui apparaÃ®t une fois que lâ€™action GitHub sâ€™est exÃ©cutÃ©e.
diff --git a/guide/using-plugins.md b/guide/using-plugins.md
--- guide/using-plugins.md
+++ guide/using-plugins.md
@@ -39,13 +39,13 @@
 Vous pouvez Ã©galement trouver les plugins qui suivent les [conventions recommandÃ©es](./api-plugin.md#conventions) en faisant une [recherche npm de vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) pour les plugins Vite ou une [recherche npm de rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) pour les plugins Rollup.

 ## Forcer lâ€™ordre des plugins

-Pour assurer la compatibilitÃ© avec certains plugins Rollup, il est possible quâ€™il soit nÃ©cessaire de forcer lâ€™ordre dâ€™un plugin ou de seulement lâ€™appliquer pour le build. Cela devrait Ãªtre un dÃ©tail dâ€™implÃ©mentation des plugins Vite. Vous pouvez forcer la position dâ€™un plugin avec le modifieur `enforce`â€¯:
+Pour assurer la compatibilitÃ© avec certains plugins Rollup, il est possible quâ€™il soit nÃ©cessaire de forcer lâ€™ordre dâ€™un plugin ou de seulement lâ€™appliquer pour la compilation. Cela devrait Ãªtre un dÃ©tail dâ€™implÃ©mentation des plugins Vite. Vous pouvez forcer la position dâ€™un plugin avec le modifieur `enforce`â€¯:

 - `pre`â€¯: invoque le plugin avant les plugins du noyau de Vite
 - par dÃ©fautâ€¯: invoque le plugin aprÃ¨s les plugins du noyau de Vite
-- `post`â€¯: invoque le plugin aprÃ¨s les plugins de build de Vite
+- `post`â€¯: invoque le plugin aprÃ¨s les plugins de compilation de Vite

 ```js
 // vite.config.js
 import image from '@rollup/plugin-image'
@@ -64,9 +64,9 @@
 Allez voir le [Guide de lâ€™API pour plugin](./api-plugin.md#ordre-du-plugin) pour de plus amples informations, et soyez attentifs Ã  lâ€™indication `enforce` ainsi quâ€™aux instructions dâ€™utilisation pour les plugins populaires dans la liste de compatibilitÃ© [Vite Rollup Plugins](https://vite-rollup-plugins.patak.dev).

 ## Application conditionnelle

-Par dÃ©faut, les plugins sont invoquÃ©s Ã  la fois pour le dÃ©veloppement et pour le build. Dans les cas oÃ¹ un plugin doit Ãªtre appliquÃ© conditionnellement seulement pour le dÃ©veloppement ou pour le build, utilisez la propriÃ©tÃ© `apply` pour lâ€™invoquer seulement durant `'build'` ou `'serve'`â€¯:
+Par dÃ©faut, les plugins sont invoquÃ©s Ã  la fois pour le dÃ©veloppement et pour la compilation. Dans les cas oÃ¹ un plugin doit Ãªtre appliquÃ© conditionnellement seulement pour le dÃ©veloppement ou pour la compilation, utilisez la propriÃ©tÃ© `apply` pour lâ€™invoquer seulement durant `'build'` ou `'serve'`â€¯:

 ```js
 // vite.config.js
 import typescript2 from 'rollup-plugin-typescript2'
diff --git a/guide/why.md b/guide/why.md
--- guide/why.md
+++ guide/why.md
@@ -11,9 +11,9 @@
 Vite a pour but de rÃ©gler ces problÃ¨mes en sâ€™appuyant sur les derniÃ¨res avancÃ©es de lâ€™Ã©cosystÃ¨meâ€¯: la possibilitÃ© dâ€™utiliser des modules ES natifs dans le navigateur, et lâ€™apparition dâ€™outils JavaScripts Ã©crits Ã  lâ€™aide de langages compilÃ©s.

 ### DÃ©marrage lent du serveur

-Lorsque vous dÃ©marrez le serveur de dÃ©veloppement Ã  froid, si votre configuration de build est basÃ©e sur un bundler, il doit rapidement crawler puis builder toute votre application avant quâ€™elle ne puisse Ãªtre servie.
+Lorsque vous dÃ©marrez le serveur de dÃ©veloppement Ã  froid, si votre configuration de compilation est basÃ©e sur un bundler, il doit rapidement crawler puis compiler toute votre application avant quâ€™elle ne puisse Ãªtre servie.

 Vite raccourcit la durÃ©e du dÃ©marrage du serveur en divisant dâ€™abord les modules dâ€™une application en deux catÃ©goriesâ€¯: les **dÃ©pendances** et le **code source**.

 - Les **dÃ©pendances** consistent le plus souvent en du JavaScript qui ne change pas pendant le dÃ©veloppement. Certaines dÃ©pendances dâ€™une taille consÃ©quente (par exemple les librairies de composants comportant des centaines de modules) sont aussi relativement coÃ»teuses Ã  traiter.
@@ -29,9 +29,9 @@
   ![esm based dev server](/images/esm.png)

 ### RafraÃ®chissement lent

-Quand un fichier est Ã©ditÃ© dans le contexte dâ€™une configuration de build basÃ©e sur un bundler, il est inefficace de refaire le build de zÃ©ro, pour des raisons Ã©videntesâ€¯: la durÃ©e de rafraÃ®chissement va augmenter linÃ©airement en fonction de la taille de lâ€™application.
+Quand un fichier est Ã©ditÃ© dans le contexte dâ€™une configuration de compilation basÃ©e sur un bundler, il est inefficace de refaire la compilation de zÃ©ro, pour des raisons Ã©videntesâ€¯: la durÃ©e de rafraÃ®chissement va augmenter linÃ©airement en fonction de la taille de lâ€™application.

 Certains serveurs de dÃ©veloppement de bundlers gardent leurs opÃ©rations en mÃ©moire, et peuvent ainsi invalider seulement une certaine partie du graphe des modules lorsquâ€™un fichier est modifiÃ©, mais il y a toujours besoin de reconstruire lâ€™intÃ©gralitÃ© du bundle et de recharger la page web. Reconstruire le bundle est coÃ»teux, et recharger la page ne permet pas de conserver lâ€™Ã©tat de lâ€™application. Câ€™est la raison pour laquelle certains bundlers supportent le remplacement de modules Ã  la volÃ©e (_hot module replacement_ ou _HMR_)â€¯: cela permet de rafraÃ®chir un module Â«â€¯Ã  chaudâ€¯Â», sans affecter le reste de la page. Cela amÃ©liore grandement lâ€™expÃ©rience de dÃ©veloppement â€“â€¯cependant, en pratique nous avons remarquÃ© que mÃªme la vitesse des mises Ã  jour Ã  la volÃ©e se dÃ©tÃ©riore nettement en fonction de la taille de lâ€™application.

 Avec Vite, le remplacement des modules Ã  la volÃ©e est effectuÃ© Ã  travers les modules ES natifs. Quand un fichier est Ã©ditÃ©, Vite peut invalider seulement prÃ©cisÃ©ment le module correspondant ainsi que le code environnant sâ€™il y lieu, ce qui permet de rendre le rafraÃ®chissement Ã  la volÃ©e rapide en toutes circonstances, peu importe la taille de votre application.
@@ -43,13 +43,13 @@
 ## Pourquoi faire un bundle de productionâ€¯?

 MÃªme si les modules ES natifs sont dÃ©sormais largement supportÃ©s, les utiliser en production sans bundling reste inefficace (mÃªme avec HTTP/2) Ã  cause des allers-retours causÃ©s par les imports imbriquÃ©s. Pour obtenir une meilleure performance de chargement en production, il reste plus efficace de bundler votre code en Ã©liminant le code inutile (_tree-shaking_), en usant du chargement opportun (_lazy loading_) et du fractionnement en morceaux (_common chunk splitting_) (qui permet de favoriser la mise en cache).

-Il nâ€™est pas simple de concilier le fait de rendre un build optimisÃ© et dâ€™assurer que le comportement en dÃ©veloppement et en production soit cohÃ©rent. Câ€™est la raison pour laquelle Vite fournit une [commande de build](./build) qui inclut dâ€™origine de nombreuses [optimisations de performance](./features#optimisations-du-build).
+Il nâ€™est pas simple de concilier le fait de rendre une compilation optimisÃ©e et dâ€™assurer que le comportement en dÃ©veloppement et en production soit cohÃ©rent. Câ€™est la raison pour laquelle Vite fournit une [commande de compilation](./build) qui inclut dâ€™origine de nombreuses [optimisations de performance](./features#optimisations-de-la-compilation).

 ## Pourquoi ne pas utiliser esbuild pour le bundleâ€¯?

-Bien quâ€™`esbuild` soit trÃ¨s rapide et soit dÃ©jÃ  capable de bundler des librairies, certaines fonctionnalitÃ©s nÃ©cessaires pour le bundle dâ€™_applications_ sont toujours en cours de dÃ©veloppement â€”â€¯en particulier le fractionnement du code et la gestion du CSS. Pour le moment, Rollup est plus mature et flexible Ã  ces Ã©gards. Ceci dit, nous nâ€™excluons pas dâ€™utiliser `esbuild` pour le build de production une fois que ces sujets seront traitÃ©s.
+Bien quâ€™`esbuild` soit trÃ¨s rapide et soit dÃ©jÃ  capable de bundler des librairies, certaines fonctionnalitÃ©s nÃ©cessaires pour le bundle dâ€™_applications_ sont toujours en cours de dÃ©veloppement â€”â€¯en particulier le fractionnement du code et la gestion du CSS. Pour le moment, Rollup est plus mature et flexible Ã  ces Ã©gards. Ceci dit, nous nâ€™excluons pas dâ€™utiliser `esbuild` pour la compilation de production une fois que ces sujets seront traitÃ©s.

 ## En quoi Vite diffÃ¨re-t-il de â€¦â€¯?

 Vous pouvez vous rendre Ã  la [section Comparaisons](./comparisons) pour plus de dÃ©tails sur la faÃ§on dont Vite diffÃ¨re des autres outils similaires.
